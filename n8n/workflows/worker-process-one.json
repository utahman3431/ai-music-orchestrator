{
  "name": "Worker - Process One Job",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "worker/run",
        "options": {
          "responseData": "={{$json}}"
        }
      },
      "name": "Webhook - Worker Run",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -250,
        300
      ],
      "webhookId": "worker-run"
    },
    {
      "parameters": {
        "code": "const fs = require('fs/promises');\nconst path = require('path');\n\nconst root = '/data/orchestration';\nconst queueDequeueUrl = 'http://127.0.0.1:5678/webhook/queue/dequeue';\nconst body = items[0].json || {};\nconst workerId = body.worker || 'worker-1';\n\nconst tokenExpected = process.env.WORKER_TOKEN || process.env.N8N_WORKER_TOKEN;\nconst tokenProvided = (body.query && body.query.token) || body.token;\nif (tokenExpected && tokenProvided !== tokenExpected) {\n  throw new Error('invalid worker token');\n}\n\nconst serviceMap = {\n  audio: process.env.AUDIO_URL || 'http://192.168.10.133:8012',\n  image: process.env.IMAGE_URL || 'http://192.168.10.133:8011',\n  video: process.env.VIDEO_URL || 'http://192.168.10.133:8013',\n  text: process.env.LLM_URL || 'http://192.168.10.133:11434',\n};\n\nasync function dequeue() {\n  const res = await fetch(queueDequeueUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ worker: workerId }),\n  });\n  if (!res.ok) throw new Error(`dequeue failed ${res.status}`);\n  return res.json();\n}\n\nconst dq = await dequeue();\nif (dq.status === 'empty') {\n  return [{ json: { status: 'idle' } }];\n}\n\nconst job = dq.job;\nconst jobPath = dq.job_path;\nconst statePath = path.join(root, 'state.json');\nconst state = JSON.parse(await fs.readFile(statePath, 'utf8'));\n\nconst serviceUrl = serviceMap[job.type] || serviceMap.text;\nif (!serviceUrl) throw new Error(`no service for job type ${job.type}`);\n\nasync function callService(url, payload) {\n  const res = await fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(payload),\n  });\n  if (!res.ok) {\n    const text = await res.text();\n    throw new Error(`service error ${res.status} ${text}`);\n  }\n  return res.json();\n}\n\nlet result;\nlet status = 'completed';\nlet error = null;\ntry {\n  if (job.type === 'text') {\n    // simple LLM call for text edit\n    const payload = {\n      model: job.params.model || 'llama3:8b',\n      prompt: job.params.prompt || 'Describe the music piece.',\n      stream: false,\n    };\n    result = await callService(`${serviceUrl}/api/generate`, payload);\n  } else {\n    const payload = {\n      job_id: job.id,\n      output_dir: job.params.output_dir || undefined,\n      ...job.params,\n    };\n    result = await callService(`${serviceUrl}/generate`, payload);\n  }\n} catch (e) {\n  status = 'error';\n  error = e.message;\n}\n\njob.status = status;\njob.updated_at = new Date().toISOString();\nif (status === 'completed') {\n  job.artifacts = job.artifacts || [];\n  if (result && result.path) job.artifacts.push(result.path);\n} else {\n  job.error = error;\n}\n\nawait fs.writeFile(jobPath, JSON.stringify(job, null, 2));\n\n// tidy state and move summaries\nif (status === 'completed') {\n  delete state.processing[job.id];\n  await fs.mkdir(path.join(root, 'completed'), { recursive: true });\n  await fs.writeFile(path.join(root, 'completed', `${job.id}.json`), JSON.stringify(job, null, 2));\n} else {\n  const retry = state.processing[job.id]?.retry || 0;\n  if (retry < 2) {\n    // requeue with incremented retry\n    state.processing[job.id] = {\n      worker: workerId,\n      started_at: new Date().toISOString(),\n      heartbeat_at: new Date().toISOString(),\n      retry: retry + 1,\n    };\n    const queuePath = path.join(root, 'queue.json');\n    const queue = JSON.parse(await fs.readFile(queuePath, 'utf8'));\n    queue.pending.push({\n      id: job.id,\n      type: job.type,\n      priority: job.params.priority || 0,\n      submitted_at: new Date().toISOString(),\n      payload_path: path.relative(root, jobPath),\n    });\n    await fs.writeFile(queuePath, JSON.stringify(queue, null, 2));\n  } else {\n    delete state.processing[job.id];\n    await fs.mkdir(path.join(root, 'failures'), { recursive: true });\n    await fs.writeFile(path.join(root, 'failures', `${job.id}.json`), JSON.stringify(job, null, 2));\n  }\n}\n\nawait fs.writeFile(statePath, JSON.stringify(state, null, 2));\nreturn [{ json: { status, job_id: job.id, result, error } }];"
      },
      "name": "Code - Dispatch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        200,
        300
      ]
    }
  ],
  "connections": {
    "Webhook - Worker Run": {
      "main": [
        [
          {
            "node": "Code - Dispatch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "tags": [
    {
      "name": "ai-music"
    }
  ]
}
